# RocketMQ——Consumer端自动地不间断地发起拉取消息的业务逻辑

对于Consumer订阅的topic实现自动拉取消息的两个场景：第一，PUSH模式下的消息消费；第二，PULL模式下的调度消费。在这两种场景下面定时的检查Consumer订阅的topic路由信息的变化，对初次订阅的topic或有变化的topic生成MessageQueue和ProcessQueue对象，并创建PullRequest对象放入拉取消息服务线程中，由该线程不间断地执行拉取消息的工作直到再次检测到ProcessQueue对象的dropped为true为止。

该RebalanceService服务线程的run方法中，每隔10秒钟就执行一次MQClientInstance.doRebalance()方法，在该方法中遍历MQClientInstance.consumerTable:ConcurrentHashMap<String/* group */, MQConsumerInner>变量，对每个MQConsumerInner对象，若是DefaultMQPushConsumerImpl（即PUSH模式）则执行RebalancePushImpl.doRebalance()方法，若是DefaultMQPullConsumerImpl（即PULL模式）则执行RebalancePullImpl.doRebalance()方法。

RebalancePushImpl和RebalancePullImpl类继承了RebalanceImpl抽象类。调用这两个子类的doRebalance方法，其实都是调用的抽象类RebalanceImpl的doRebalance方法。

在doRebalance方法中，首先获取RebalanceImpl. subscriptionInner:ConcurrentHashMap<String /* topic */, SubscriptionData>队列的Key值（即topic的集合），然后以每个topic值为参数调用RebalanceImpl.rebalanceByTopic(String topic)方法（详见1和2小节），该方法为topic所分配的MessageQueue创建ProcessQueue对象，并且创建拉取消息请求放入后台服务线程中自动执行拉取逻辑；待topic集合遍历完之后再调用RebalanceImpl.truncateMessageQueueNotMyTopic()方法,该方法的大致逻辑如下：

遍历RebalanceImpl.processQueueTable队列中的每个MessageQueue对象的topic，若该topic不在RebalanceImpl.subscriptionInner: ConcurrentHashMap<String /* topic */, SubscriptionData>列表中，则从RebalanceImpl.processQueueTable队列将该MessageQueue对象的记录删掉，然后置对应的ProcessQueue对象的dropped为true；

### 1 为topic下的所有MessageQueue创建拉取消息请求（广播模式下）

检查RebalanceImpl.messageModel变量，若等于BROADCASTING，则执行RebalanceImpl. **rebalanceByTopic** (String topic)方法中的广播模式下的逻辑，该方法的主要目的是为topic下的所有MessageQueue集合中的每个MessageQueue对象创建ProcessQueue对象，并且对于PUSH模式将拉取消息的请求放入服务线程（PullMessageService）中。大致逻辑如下：

1、以topic值为key值从RebalanceImpl.topicSubscribeInfoTable: ConcurrentHashMap<String/* topic */, Set<MessageQueue>>列表中获取MessageQueue集合；

2、以topic和上一步获得的MessageQueue集合为参数调用RebalanceImpl.updateProcessQueueTableInRebalance(String topic, Set<MessageQueue> mqSet)方法并获取返回结果。

3、若返回结果为true（即RebalanceImpl.processQueueTable列表有变化）则调用RebalanceImpl.messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided)方法；对于PUSH模式下面没有相应的处理逻辑，即messageQueueChanged方法为空；对于PULL模式下会调用RebalancePullImpl对象的messageQueueChanged方法，此方法的目的是对于采用了计划消息拉取服务的应用来说，当Consumer订阅的MessageQueue有变动或者或者ProcessQueue有更新时触发消息拉取动作，大致逻辑如下：

3.1）获取DefaultMQPullConsumer.messageQueueListener变量的值，该变量只有在应用层使用MQPullConsumerScheduleService类来进行计划拉取消息服务时才会设置MessageQueueListener对象；该对象是MQPullConsumerScheduleService类的内部类MessageQueueListenerImpl类的实例；

3.2）调用该内部类的实例MessageQueueListener对象的messageQueueChanged方法；

### 2 为Topic所分配每个MessageQueue创建拉取消息请求（集群模式下）

检查RebalanceImpl.messageModel变量，若等于CLUSTERING，则执行RebalanceImpl. **rebalanceByTopic** (String topic)方法中的集群模式下的逻辑，该方法的主要目的是首先为topic分配MessageQueue集合，然后为集合中的每个MessageQueue对象创建ProcessQueue对象，最后对于PUSH模式将拉取消息的请求放入服务线程（PullMessageService）中。

1、以入参topic值从RebalanceImpl.topicSubscribeInfoTable: ConcurrentHashMap<String/* topic */, Set<MessageQueue>>变量中获取对应的MessageQueue集合（命名为mqSet）；

2、获取topic的Broker地址。以入参topic值从MQClientInstance.topicRouteTable:ConcurrentHashMap<String/* Topic*/,TopicRouteData>变量中获取对应的TopicRouteData对象，然后取该TopicRouteData对象的brokerDatas:List<BrokerData>集合；若该集合为空则直接返回null；否则若该集合不为空，则取第一个BrokerData对象，从该对象的brokerAddrs: HashMap<Long/* brokerId */, String/* broker address */>变量中获取brokerId=0的Broker地址（即主用Broker），若没有主用Broker则获取备用Broker地址；

3、若上一步获取的Broker地址为空，则调用MQClientInstance. updateTopicRouteInfoFromNameServer方法从NameServer获取之后再按第2步的方法查找topic对应的Broker地址；循环执行直到找到Broker地址为止；

4、以consumerGroup为参数向该Broker发送GET_CONSUMER_LIST_BY_GROUP请求码，获取以该consumerGroup为名的ClientId集合；在Broker收到请求之后，从ConsumerManager.consumerTable中获取ConsumerGroupInfo对象，然后遍历该对象的channelInfoTable集合，将集合的每个ClientChannelInfo对象的clientId变量值作为ClientId集合；

5、若第1步的MessageQueue集合（名为mqSet）和上一步的ClientId集合都不为null则继续进行下面操作，否则直接退出该方法；

6、则调用RebalanceImpl. **allocateMessageQueueStrategy.allocate** (String consumerGroup, String currentCID, List<MessageQueue> mqAll, List<String> cidAll)为当前Consumer分配应该消费的MessageQueue集合队列（命名allocateResultSet）；有四种分配策略，包括平均分配（AVG）、AVG_BY_CIRCLE 、CONFIG 、MACHINE_ROOM，默认为AllocateMessageQueueAveragely分配策略；

6、以topic和上一步分配的MessageQueue集合（名为allocateResultSet）为参数调用RebalanceImpl. **updateProcessQueueTableInRebalance** (String topic, Set<MessageQueue> mqSet)方法，该方法是对每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl.processQueueTable队列中，然后对于PUSH模式下向后台线程放入拉取消息的请求对象，最后一个标记位表示是否对RebalanceImpl.processQueueTable列表有修改，若有则返回true；（详见5.3.3小节）

7、若上一步的返回结果为true（即RebalanceImpl.processQueueTable列表有记录变化时），则调用RebalanceImpl.messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided)方法，其中mqAll为第1步的MessageQueue集合（名为mqSet），mqDivided为第6步的MessageQueue集合（名为allocateResultSet）。对于PUSH模式下面没有相应的处理逻辑，即messageQueueChanged方法为空；对于PULL模式下会调用RebalancePullImpl对象的messageQueueChanged方法，此方法的目的是对于采用了计划消息拉取服务的应用来说，当Consumer订阅的MessageQueue有变动或者或者ProcessQueue有更新时触发消息拉取动作，大致逻辑如下：

7.1）获取DefaultMQPullConsumer.messageQueueListener变量的值，该变量只有在应用层使用MQPullConsumerScheduleService类来进行计划拉取消息服务时才会设置MessageQueueListener对象；该对象是MQPullConsumerScheduleService类的内部类MessageQueueListenerImpl类的实例；

7.2）调用该内部类的实例MessageQueueListener对象的messageQueueChanged方法；

### 3 为每个消息队列维护一个消息处理队列（updateProcessQueueTableInRebalance）

一个MessageQueue消息队列的消息分配一个消息处理队列ProcessQueue来进行消费处理，这两个队列的关系存储在RebalanceImpl.processQueueTable队列变量中。

在拉取消息之前会为该Consumer分配消费的消息队列集合mqSet，RebalanceImpl.updateProcessQueueTableInRebalance(String topic, Set<MessageQueue> mqSet)方法的目的是，第一，为该消息队列集合中的每个MessageQueue对象创建一个ProcessQueue对象并存入RebalanceImpl.processQueueTable队列变量中，并将processQueueTable队列中其他的MessageQueue记录删除掉；第二，对于PUSH模式要创建PullRequest对象并放入消息拉取线程（PullMessageService）的pullRequestQueue队列中，由该线程进行消息的拉取处理；大致逻辑如下：

1、遍历RebalanceImpl.processQueueTable:ConcurrentHashMap <MessageQueue, ProcessQueue>集合，检查该集合中的每条记录，对于不在入参MessageQueue集合中记录或者记录中ProcessQueue对象的距离上次拉取时间已经超时，则从该列表中删除掉该记录：

1.1）首先检查MessageQueue的topic值是否等于参数topic；若不相等，则继续遍历下一条记录；若相等，则继续下面的处理逻辑；

1.2) 检查满足第1步的MessageQueue对象是否在入参MessageQueue集合中：若不在此集合中，则将该记录对应的ProcessQueue对象的dropped变量置为true，并且调用 **removeUnnecessaryMessageQueue** 方法删除该消息队列的消费进度（详见4小节），若删除成功则再将该消息队列的记录从RebalanceImpl.processQueueTable列表中删除并置 **changed=true** ；若在此集合中，则检查ProcessQueue距离上次拉取时间（ProcessQueue. lastPullTimestamp）是否已经超时（默认120秒），若已经超时，并且消费类型为被动消费（即为PUSH模式，RebalancePushImpl），则将该记录对应的ProcessQueue对象的dropped变量置为true，并且调用 **removeUnnecessaryMessageQueue** 方法删除该消息队列的消费进度（详见4小节）, 若删除成功则再将遍历到的此条记录从RebalanceImpl.processQueueTable列表中删除并置 **changed=true** ；

2、遍历入参MessageQueue集合，检查该集合中的每个MessageQueue对象，保证每个MessageQueue对象在processQueueTable队列中都有ProcessQueue对象。对于不在RebalanceImpl.processQueueTable:ConcurrentHashMap <MessageQueue, ProcessQueue>列表中的MessageQueue对象，要构建PullRequest对象以及processQueueTable集合的K-V值，构建过程如下：

2.1）初始化PullRequest对象，并设置consumerGroup、messageQueue变量值， **初始化新的ProcessQueue对象** 赋值给PullRequest对象的processQueue变量；

2.2）调用RebalanceImpl. **computePullFromWhere** (MessageQueue mq)方法获取该MessageQueue对象的下一个消费偏移值offset，详见5小节；

2.3）若该offset值大于等于0，则首先用该offset值设置PullRequest对象的nextOffset值；然后将该PullRequest对象放入局部变量pullRequestList:List<PullRequest>集合中；再将遍历到的MessageQueue对象和该PullRequest对象的processQueue变量存入RebalanceImpl.processQueueTable变量中；最后置 **change等于true** ；

3、以上一步的局部变量pullRequestList集合为参数调用RebalanceImpl.dispatchPullRequest(List<PullRequest> pullRequestList)方法。该方法的目的是将拉取消息的请求对象PullRequest放入拉取消息的服务线程（PullMessageService）中，并在后台执行拉取消息的业务逻辑。对于PULL模式，是由应用层触发拉取消息，故在RebalancePullImpl子类中该方法没有业务逻辑；对于子类RebalancePushImpl的dispatchPullRequest方法，大致逻辑如下：

遍历入参List<PullRequest>列表，以每个PullRequest对象为参数调用DefaultMQPushConsumerImpl.executePullRequestImmediately(PullRequest pullRequest)方法，在该方法中只调用MQClientInstance.pullMessageService.executePullRequestImmediately(PullRequest pullRequest)方法，将PullRequest对象放入PullMessageService服务线程的pullRequestQueue队列中；在启动Consumer时启动了PullMessageService服务线程，由该服务线程在后台监听pullRequestQueue队列的数据，若队列中有数据到来则执行相应的业务逻辑（详见4小节）；

4、返回 **change** 的值，该值在进入updateProcessQueueTableInRebalance方法时初始化为false，若在上述步骤中没有重置则返回false；

### 4 删除未使用的消息队列的消费进度（removeUnnecessaryMessageQueue）

该方法主用目的是：首先将指定MessageQueue消息队列的消费进度向Broker同步；然后从本地删除该消息队列的消费进度；最后对于PUSH模式下面的顺序消费从Broker端将消息队列解锁。

一、对于PUSH消费模式，即调用RebalancePushImpl.removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq)方法，大致逻辑如下：

1、调用DefaultMQPushConsumerImpl.offsetStore.persist(MessageQueue mq)方法：对于广播模式下offsetStore初始化为LocalFileOffsetStore对象，该对象的persist方法没有处理逻辑；对于集群模式下offsetStore初始化为RemoteBrokerOffsetStore对象，该对象的persist方法中，首先以入参MessageQueue对象为key值从RemoteBrokerOffsetStore.offsetTable: ConcurrentHashMap<MessageQueue, AtomicLong>变量中获取偏移量offset值，然后调用updateConsumeOffsetToBroker(MessageQueue mq, long offset)方法向Broker发送UPDATE_CONSUMER_OFFSET请求码，向Broker进行消费进度信息的同步；

2、调用DefaultMQPushConsumerImpl.offsetStore.removeOffset(MessageQueue mq)方法：对于广播模式下offsetStore初始化为LocalFileOffsetStore对象，该对象的removeOffset方法没有处理逻辑；对于集群模式下offsetStore初始化为RemoteBrokerOffsetStore对象，该对象的removeOffset方法中，将该MessageQueue对象的记录中从RemoteBrokerOffsetStore.offsetTable: ConcurrentHashMap<MessageQueue, AtomicLong>集合中删除;

3、若DefaultMQPushConsumerImpl.consumeOrderly变量等于true（顺序消费类型），并且RebalanceImpl.messageModel变量等于CLUSTERING（集群）,则：首先尝试在1秒内获取到ProcessQueue.lockConsume:Lock的互斥锁；若获取到互斥锁则向该MessageQueue对象的BrokerName下面的主用Broker发送UNLOCK_BATCH_MQ请求码请求对MessageQueue进行解锁操作，采用oneway形式发送请求消息，发送成功则直接返回true，最后释放此互斥锁；若未获取到该lockConsume的互斥锁，则打印试图解锁的次数并返回false。在此使用ProcessQueue.lockConsume互斥锁的原因是保证在发起解锁的过程中没有线程在消费该消息队列（在回调应用层的MessageListenerOrderly实现类的consumeMessage方法时会获取该ProcessQueue.lockConsume互斥锁，与解锁形成互斥逻辑）。

二、对于PULL消费模式，即调用RebalancePullImpl.removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq)方法，大致逻辑与PUSH消费模式的第1/2步逻辑一样，只是没有释放分布式锁的处理逻辑，如下：

1、调用DefaultMQPullConsumerImpl.offsetStore.persist(MessageQueue mq)方法：对于广播模式下offsetStore初始化为LocalFileOffsetStore对象，该对象的persist方法没有处理逻辑；对于集群模式下offsetStore初始化为RemoteBrokerOffsetStore对象，该对象的persist方法中，首先以入参MessageQueue对象为key值从RemoteBrokerOffsetStore.offsetTable: ConcurrentHashMap<MessageQueue, AtomicLong>变量中获取偏移量offset值，然后调用updateConsumeOffsetToBroker(MessageQueue mq, long offset)方法向Broker发送UPDATE_CONSUMER_OFFSET请求码，向Broker进行消费进度信息的同步；

2、调用DefaultMQPullConsumerImpl.offsetStore.removeOffset(MessageQueue mq)方法：对于广播模式下offsetStore初始化为LocalFileOffsetStore对象，该对象的removeOffset方法没有处理逻辑；对于集群模式下offsetStore初始化为RemoteBrokerOffsetStore对象，该对象的removeOffset方法中，将该MessageQueue对象的记录中从RemoteBrokerOffsetStore.offsetTable: ConcurrentHashMap<MessageQueue, AtomicLong>集合中删除;

3、返回true；

### 5 获取MessageQueue队列的下一个消费偏移量（computePullFromWhere）

RebalanceImpl.computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset。

对于PULL模式（RebalancePullImpl），computePullFromWhere方法直接返回0。

对于PUSH模式（RebalancePushImpl），computePullFromWhere方法的计算逻辑如下：

1、获取DefaultMQPushConsumer.consumeFromWhere变量值，在应用层设置该值，默认值为CONSUME_FROM_LAST_OFFSET；

2、获取DefaultMQPushConsumerImpl.offsetStore对象，若为广播模式则该对象初始化为LocalFileOffsetStore；若为集群模式则该对象初始化为RemoteBrokerOffsetStore对象；

3、若consumeFromWhere值等于CONSUME_FROM_LAST_OFFSET（表示一个新的订阅组第一次启动从队列的最后位置开始消费）。

3.1）调用offsetStore.readOffset(MessageQueue mq, ReadOffsetType type)方法，其中type=ReadOffsetType.READ_FROM_STORE。

3.1.1)对于LocalFileOffsetStore对象，从本地加载offsets.json文件，然后获取该MessageQueue对象的offset值；

3.1.2)对于RemoteBrokerOffsetStore对象,获取逻辑如下：

A）以MessageQueue对象的brokername从MQClientInstance.brokerAddrTable中获取Broker的地址；若没有获取到则立即调用updateTopicRouteInfoFromNameServer方法然后再次获取；

B）构造QueryConsumerOffsetRequestHeader对象，其中包括topic、consumerGroup、queueId；然后调用MQClientAPIImpl.queryConsumerOffset (String addr, QueryConsumerOffsetRequestHeader requestHeader, long timeoutMillis)方法向Broker发送QUERY_CONSUMER_OFFSET请求码，获取消费进度Offset；

C）用上一步从Broker获取的offset更新本地内存的消费进度列表数据RemoteBrokerOffsetStore.offsetTable:ConcurrentHashMap<MessageQueue, AtomicLong>变量值；

D）返回该offset值；

3.2)检查上一步返回的offset值：

3.2.1)若该offset值大于零，则直接返回该值；

3.2.2)若该offset值等于-1：若topic是以"%RETRY%"开头，则返回0；若不是以此字符开头，则向该MessageQueue对象的brokername所在Broker发送GET_MAX_OFFSET请求码，获取该MessageQueue对象的topic和queueId对应的逻辑队列的最大逻辑偏移量，并返回该最大offset值；

3.2.3)否则直接返回-1；

4、若consumeFromWhere值等于CONSUME_FROM_FIRST_OFFSET（表示一个新的订阅组第一次启动从队列的最前位置开始消费）。

4.1）调用offsetStore.readOffset(MessageQueue mq, ReadOffsetType type)方法，其中type=ReadOffsetType.READ_FROM_STORE。逻辑与上面的3.1一样。

4.2)检查上一步返回的offset值：

若大于零，则返回该值；若等于-1，则返回0；否则返回-1；

5、若consumeFromWhere值等于CONSUME_FROM_TIMESTAMP（表示一个新的订阅组第一次启动从指定时间点开始消费）。

5.1）调用offsetStore.readOffset(MessageQueue mq, ReadOffsetType type)方法，其中type=ReadOffsetType.READ_FROM_STORE。逻辑与上面的3.1一样。

5.2）若上一步返回的offset值大于0，则返回该offset值；

5.3)若返回的offset值等于-1；若topic是以"%RETRY%"开头，则向该MessageQueue对象的brokername所在Broker发送GET_MAX_OFFSET请求码，获取该MessageQueue对象的topic和queueId对应的逻辑队列的最大逻辑偏移量，并返回该最大offset值；否则取DefaultMQPushConsumer.consumeTimestamp变量的时间戳，向该MessageQueue对象的brokername所在Broker发送SEARCH_OFFSET_BY_TIMESTAMP请求码，获取距离该时间戳最近的逻辑队列的offset值，并返回该offset值；

5.4）否则直接返回-1；